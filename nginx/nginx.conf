worker_processes auto;
pid /home/user/nginx/nginx.pid;
error_log /home/user/logs/nginx.error.log warn;

# OpenResty already includes ngx_lua; no load_module needed


events { worker_connections 1024; }

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    charset utf-8;

    sendfile on;
    keepalive_timeout 65;
    access_log /home/user/logs/nginx.access.log;

    # Non-root temp directories
    client_body_temp_path /home/user/nginx/tmp/body 1 2;
    proxy_temp_path       /home/user/nginx/tmp/proxy 1 2;
    fastcgi_temp_path     /home/user/nginx/tmp/fastcgi 1 2;
    uwsgi_temp_path       /home/user/nginx/tmp/uwsgi 1 2;
    scgi_temp_path        /home/user/nginx/tmp/scgi 1 2;

    # Shared in-memory route table (increase for more rules)
    lua_shared_dict route_dict 10m;

    # Initialize config from JSON (copy default on first run)
    init_by_lua_block {
        local dict = ngx.shared.route_dict
        local cjson = require "cjson.safe"

        local ADMIN_CONFIG_PATH = "/home/user/nginx/admin_config.json"
        local DEFAULT_CONFIG_PATH = "/home/user/nginx/default_admin_config.json"

        local function read_file(path)
            local f = io.open(path, "r")
            if not f then return nil end
            local s = f:read("*a"); f:close(); return s
        end
        local function write_file(path, content)
            local f = io.open(path, "w")
            if not f then return nil, "open failed" end
            f:write(content or ""); f:close(); return true
        end
        local function file_exists(path)
            local f = io.open(path, "r")
            if f then f:close(); return true end
            return false
        end

        -- Ensure admin config exists by copying the default once
        if not file_exists(ADMIN_CONFIG_PATH) then
            local def_txt = read_file(DEFAULT_CONFIG_PATH)
            if def_txt then
                write_file(ADMIN_CONFIG_PATH, def_txt)
            end
        end

        -- Load admin config (fallback to default file only for reading)
        local cfg
        do
            local txt = read_file(ADMIN_CONFIG_PATH)
            if not txt then txt = read_file(DEFAULT_CONFIG_PATH) end
            if txt then cfg = cjson.decode(txt) end
        end
        if type(cfg) ~= "table" then cfg = {} end
        if type(cfg.rules) ~= "table" then cfg.rules = {} end

        -- Cache to shared dict
        dict:set("admin_password", cfg.admin_password or "")
        dict:set("default_backend", cfg.default_backend or "")
        dict:set("route_rules_json", cjson.encode(cfg.rules or {}))

        -- Advanced rules cache (per-worker)
        ROUTE_CACHE = { raw = nil, parsed = {} }
    }

    # WebSocket
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # Prefer original client-facing headers
    map $http_x_forwarded_proto $forwarded_proto { default $http_x_forwarded_proto; '' $scheme; }
    map $http_x_forwarded_host  $forwarded_host  { default $http_x_forwarded_host;  '' $host;   }
    map $http_x_forwarded_port  $forwarded_port  { default $http_x_forwarded_port;  '' 443;     }

    server {
        listen 7860;
        server_name _;

        absolute_redirect off;
        port_in_redirect  off;

        # Variable used by Lua to feed proxy_pass
        set $dynamic_backend "";

        # NOTE: /webui* 与 /napcat* 的行为改由 JSON 高级规则控制

        # Static web UI to manage dynamic routes
        # Served at /admin/ui/ (not the API)
        location ^~ /admin/ui/ {
            alias /home/user/nginx/route-admin/;
            index index.html;
            add_header Cache-Control "no-store";
        }

        # /sync 通过高级路由 cfg.rules 动态转发，无需显式 location

        # NOTE: 旧版 /admin/routes 文本接口已移除，
        #       统一使用 /admin/routes.json 进行高级规则管理

        # 高级 JSON 配置 API（查询/替换）- 需管理员密码（文件持久化）
        # - GET  /admin/routes.json  -> { default_backend: string, rules: [ ... ] }
        # - POST /admin/routes.json  -> replace default and/or rules with posted JSON
        location = /admin/routes.json {
            client_max_body_size 2m;
            content_by_lua_block {
                local function unauthorized()
                    ngx.status = 403
                    ngx.say('{"error":"forbidden"}')
                    return ngx.exit(403)
                end

                local dict = ngx.shared.route_dict
                local hdr = ngx.req.get_headers()["X-Admin-Password"]
                local pass = dict:get("admin_password") or ""
                if not hdr or hdr ~= pass then
                    return unauthorized()
                end

                local cjson = require "cjson.safe"
                local CONFIG_PATH = "/home/user/nginx/admin_config.json"
                local DEFAULT_CONFIG_PATH = "/home/user/nginx/default_admin_config.json"
                local function write_file(path, content)
                    local f = io.open(path, "w")
                    if not f then return nil, "open failed" end
                    f:write(content or ""); f:close(); return true
                end
                local method = ngx.req.get_method()

                if method == "GET" then
                    ngx.header["Content-Type"] = "application/json; charset=utf-8"
                    local def = dict:get("default_backend") or ""
                    local raw = dict:get("route_rules_json") or "[]"
                    local rules = cjson.decode(raw) or {}
                    local out = { default_backend = def, rules = rules }
                    ngx.say(cjson.encode(out))
                    return
                end

                if method == "POST" then
                    ngx.req.read_body()
                    local data = ngx.req.get_body_data() or ""
                    local obj, err = (require "cjson.safe").decode(data)
                    if not obj then
                        ngx.status = 400
                        ngx.say('{"error":"invalid json"}')
                        return
                    end

                    if type(obj.default_backend) == "string" and obj.default_backend ~= "" then
                        dict:set("default_backend", obj.default_backend)
                    end

                    if obj.rules ~= nil then
                        if type(obj.rules) ~= "table" then
                            ngx.status = 400
                            ngx.say('{"error":"rules must be array"}')
                            return
                        end
                        -- sanitize rules: keep only allowed fields
                        local sanitized = {}
                        for i, r in ipairs(obj.rules) do
                            if type(r) == "table" then
                                local rr = {
                                    id = r.id,
                                    action = r.action or (r.backend and "proxy" or nil),
                                    backend = r.backend,
                                    priority = tonumber(r.priority) or 0,
                                    match = {},
                                    redirect_to = r.redirect_to,
                                    redirect_to_prefix = r.redirect_to_prefix,
                                    set_headers = r.set_headers,
                                }
                                if type(r.match) == "table" then
                                    local m = {}
                                    if type(r.match.path_equal) == "string" then m.path_equal = r.match.path_equal end
                                    if type(r.match.host) == "string" then m.host = r.match.host end
                                    if type(r.match.path_prefix) == "string" then m.path_prefix = r.match.path_prefix end
                                    if type(r.match.referer_substr) == "string" then m.referer_substr = r.match.referer_substr end
                                    if type(r.match.referer_regex) == "string" then m.referer_regex = r.match.referer_regex end
                                    if type(r.match.method) == "string" then m.method = r.match.method end
                                    if type(r.match.headers) == "table" then
                                        local hs = {}
                                        for _, h in ipairs(r.match.headers) do
                                            if type(h) == "table" and type(h.name) == "string" then
                                                local hh = { name = h.name }
                                                if type(h.contains) == "string" then hh.contains = h.contains end
                                                if type(h.regex) == "string" then hh.regex = h.regex end
                                                table.insert(hs, hh)
                                            end
                                        end
                                        if #hs > 0 then m.headers = hs end
                                    end
                                    rr.match = m
                                end
                                -- basic validation
                                if rr.action == "proxy" and type(rr.backend) ~= "string" then
                                    rr = nil
                                end
                                if rr then
                                    table.insert(sanitized, rr)
                                end
                            end
                        end

                        local raw = cjson.encode(sanitized)
                        dict:set("route_rules_json", raw)
                        dict:incr("route_rules_ver", 1, 0)
                        -- update cache in this worker immediately
                        ROUTE_CACHE = ROUTE_CACHE or { raw = nil, parsed = {} }
                        ROUTE_CACHE.raw = raw
                        ROUTE_CACHE.parsed = sanitized
                    end

                    -- persist to file
                    local function read_file(path)
                        local f = io.open(path, "r")
                        if not f then return nil end
                        local s = f:read("*a"); f:close(); return s
                    end
                    local def_cfg = (function()
                        local t = read_file(DEFAULT_CONFIG_PATH)
                        if not t then return {} end
                        return cjson.decode(t) or {}
                    end)()
                    local out = {
                        admin_password = dict:get("admin_password") or def_cfg.admin_password or "",
                        default_backend = dict:get("default_backend") or def_cfg.default_backend or "",
                        rules = (function()
                            local raw = dict:get("route_rules_json") or "[]"
                            local arr = cjson.decode(raw) or {}
                            return arr
                        end)()
                    }
                    write_file(CONFIG_PATH, cjson.encode(out))

                    ngx.header["Content-Type"] = "application/json; charset=utf-8"
                    ngx.say('{"ok":true}')
                    return
                end

                ngx.header["Allow"] = "GET, POST"
                ngx.status = 405
                ngx.say('{"error":"method not allowed"}')
            }
        }

        # 管理员密码设置接口（仅 POST）- 需当前密码校验，使用单一 JSON 文件存储
        # 请求: POST /admin/password  { "new_password": "..." }
        location = /admin/password {
            client_max_body_size 256k;
            content_by_lua_block {
                local function bad_request(msg)
                    ngx.status = 400
                    ngx.say('{"error":', require('cjson.safe').encode(msg or 'bad request'), '}')
                    return ngx.exit(400)
                end
                local function unauthorized()
                    ngx.status = 403
                    ngx.say('{"error":"forbidden"}')
                    return ngx.exit(403)
                end
                local dict = ngx.shared.route_dict
                local hdr = ngx.req.get_headers()["X-Admin-Password"]
                local pass = dict:get("admin_password") or ""
                if not hdr or hdr ~= pass then
                    return unauthorized()
                end

                if ngx.req.get_method() ~= "POST" then
                    ngx.header["Allow"] = "POST"
                    ngx.status = 405
                    ngx.say('{"error":"method not allowed"}')
                    return
                end
                ngx.req.read_body()
                local data = ngx.req.get_body_data() or ""
                local obj = require('cjson.safe').decode(data)
                if not obj then
                    return bad_request('invalid json')
                end
                local newp = obj.new_password
                if type(newp) ~= 'string' or newp == '' then
                    return bad_request('new_password required')
                end
                local cjson = require 'cjson.safe'
                local CONFIG_PATH = "/home/user/nginx/admin_config.json"
                local DEFAULT_CONFIG_PATH = "/home/user/nginx/default_admin_config.json"
                local function write_file(path, content)
                    local f = io.open(path, "w")
                    if not f then return nil, "open failed" end
                    f:write(content or ""); f:close(); return true
                end
                dict:set("admin_password", newp)
                local function read_file(path)
                    local f = io.open(path, "r")
                    if not f then return nil end
                    local s = f:read("*a"); f:close(); return s
                end
                local def_cfg = (function()
                    local t = read_file(DEFAULT_CONFIG_PATH)
                    if not t then return {} end
                    return cjson.decode(t) or {}
                end)()
                local cfg = {
                    admin_password = newp,
                    default_backend = dict:get("default_backend") or def_cfg.default_backend or "",
                    rules = (function()
                        local raw = dict:get("route_rules_json") or "[]"
                        return cjson.decode(raw) or {}
                    end)()
                }
                write_file(CONFIG_PATH, cjson.encode(cfg))
                ngx.header["Content-Type"] = "application/json; charset=utf-8"
                ngx.say('{"ok":true}')
            }
        }

        # 动态路由（所有路径均可按高级规则匹配；除 /admin/ui 与 /admin/routes.json 外）
        location / {
            # choose backend based on shared dict
            access_by_lua_block {
                local dict = ngx.shared.route_dict
                local cjson = require "cjson.safe"
                local re_find = ngx.re.find

                local referer = ngx.var.http_referer or ""
                local host = ngx.var.host or ""
                local uri = ngx.var.uri or ""
                local method = ngx.req.get_method()
                local headers = ngx.req.get_headers()

                local function escape_pattern(s)
                    return (s:gsub("[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%0"))
                end

                local function rule_matches(rule)
                    local m = rule.match or {}
                    if m.path_equal and uri ~= m.path_equal then return false end
                    if m.host and m.host ~= host then return false end
                    if m.path_prefix and not uri:find("^" .. escape_pattern(m.path_prefix)) then return false end
                    if m.method and m.method ~= method then return false end
                    if m.referer_substr and (referer == "" or not referer:find(m.referer_substr, 1, true)) then return false end
                    if m.referer_regex and (referer == "" or not re_find(referer, m.referer_regex, "jo")) then return false end
                    if m.headers then
                        for _, h in ipairs(m.headers) do
                            local hv = headers[h.name] or headers[(h.name or ""):lower()]
                            if not hv then return false end
                            hv = tostring(type(hv) == "table" and hv[1] or hv)
                            if h.contains and not hv:find(h.contains, 1, true) then return false end
                            if h.regex and not re_find(hv, h.regex, "jo") then return false end
                        end
                    end
                    return true
                end

                local chosen = dict:get("default_backend") or "http://127.0.0.1:6185"
                local action = "proxy"

                -- Advanced JSON rules (cached per-worker)
                ROUTE_CACHE = ROUTE_CACHE or { raw = nil, parsed = {} }
                local raw = dict:get("route_rules_json") or "[]"
                if ROUTE_CACHE.raw ~= raw then
                    local arr = cjson.decode(raw) or {}
                    ROUTE_CACHE.raw = raw
                    ROUTE_CACHE.parsed = arr
                end

                local best_backend = nil
                local best_rule = nil
                local best_priority, best_path_len, best_ref_len = -1, -1, -1
                for _, r in ipairs(ROUTE_CACHE.parsed or {}) do
                    if type(r) == "table" then
                        if rule_matches(r) then
                            local pri = tonumber(r.priority) or 0
                            local pl = 0
                            local rl = 0
                            if r.match and type(r.match.path_prefix) == "string" then pl = #r.match.path_prefix end
                            if r.match and type(r.match.referer_substr) == "string" then rl = #r.match.referer_substr end
                            if (pri > best_priority) or (pri == best_priority and pl > best_path_len) or (pri == best_priority and pl == best_path_len and rl > best_ref_len) then
                                best_priority, best_path_len, best_ref_len = pri, pl, rl
                                best_backend = r.backend
                                best_rule = r
                            end
                        end
                    end
                end

                if best_rule then
                    if best_rule.action == "redirect" then
                        local target = best_rule.redirect_to
                        if not target and best_rule.redirect_to_prefix and best_rule.match and best_rule.match.path_prefix then
                            local pfx = best_rule.match.path_prefix
                            local rest = string.sub(uri, #pfx + 1)
                            target = (best_rule.redirect_to_prefix or "") .. rest
                        end
                        target = target or "/"
                        return ngx.redirect(target, 301)
                    else
                        chosen = best_backend or chosen
                        if best_rule.set_headers and type(best_rule.set_headers) == "table" then
                            for _, h in ipairs(best_rule.set_headers) do
                                if type(h) == "table" and type(h.name) == "string" and type(h.value) == "string" then
                                    ngx.req.set_header(h.name, h.value)
                                end
                            end
                        end
                    end
                else
                    -- no matched advanced rule; use default backend
                end

                ngx.var.dynamic_backend = chosen
            }

            proxy_http_version 1.1;
            proxy_set_header Host              $forwarded_host;
            proxy_set_header X-Forwarded-Host  $forwarded_host;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $forwarded_proto;
            proxy_set_header X-Forwarded-Port  $forwarded_port;
            proxy_set_header Upgrade           $http_upgrade;
            proxy_set_header Connection        $connection_upgrade;
            proxy_read_timeout 600s;
            proxy_send_timeout 600s;

            proxy_pass $dynamic_backend;
        }
    }
}
